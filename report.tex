\documentclass[12pt]{report}

% Packages (keep sorted)
\usepackage{
    algorithm,      % For algorithm environment
    algpseudocode,  % For pseudocode
    hyperref,       % For PDF bookmarks
}

% PDF bookmarks setup (keep sorted)
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
}

\begin{document}

% Info section

% TODO(sanjay): come up with something more creative
\title{RTX Project Report}

\author{
    Craig, Shale\\
    20371384\\
    \texttt{sakcraig@uwaterloo.ca}
    \and
    Klen, Alex\\
    XXXXXXXX\\
    \texttt{XXXX@uwaterloo.ca}
    \and
    Menakuru, Sanjay\\
    20374915\\
    \texttt{smenakur@uwaterloo.ca}
    \and
    Wei, Jonathan\\
    20376489\\
    \texttt{j25wei@uwaterloo.ca}
}

\maketitle

\begin{abstract}
    Here is our awesome abstract
\end{abstract}

\tableofcontents
\listofalgorithms

% NOTE(sanjay): uncomment these if we add any figures or tables
% \listoffigures
% \listoftables


\part{Introduction}

\part{Kernel Implementation}
% This part is at max 30 pages.

\chapter{Scheduler}
% Make sure to include pseudocode and testing, if appropriate.

\section{Description}

\section{Running Time Analysis}

\chapter{Memory Allocator}
% Make sure to include pseudocode and testing, if appropriate.

\section{Description}
    The memory allocator was designed with two orthogonal layers. The first is
    called the `block layer', and is responsible for allocating and deallocating
    blocks at a low level. The second is called the `metadata layer'; this layer
    builds upon the work done by the block layer, and adds the ability to store
    metadata about blocks. We will describe both of these layers independently.

\subsection{Block Layer}
    The block layer has a conceptually simple role. It is responsible for
    managing a pool of contiguous memory. Given a start memory address, an
    end memory address, and a block size, the block
    layer must provide two pieces of functionality. It must support allocating
    a block from the pool, and it must support freeing a block back into the
    pool. One design constraint is that it must prefer reusing a previously
    allocated block that has been freed, rather than handing out a block that
    has never been allocated before. The reason for this constraint will
    become clear when discussing the metadata layer.

    See Algorithm \ref{code:mem_block} for a pseudocode implementation of this
    layer. Note that this layer returns an error code when it runs out of
    memory. Further, this layer does some rudimentary sanity checking but
    doesn't handle some obvious error conditions. For example, this layer allows
    blocks to be inserted into the free list twice (assuming a trivial linked
    list implementation). This is not an error; it is the responsibility of
    the metadata layer to never allow this to happen. Finally, it is important
    to point out that this layer automatically zeroes memory. This is slightly
    detrimental to performance, but allows user processes to use binary
    comparisons between structs without caring about garbage in the struct's
    padding. We deemed this convenience worth the slight performance overhead.

    \begin{algorithm}
        \caption{Block layer pseudocode}
        \label{code:mem_block}
        \begin{algorithmic}[1]

            \State $blockSize \gets 2^7$
            \Comment{Blocksize in bytes (configurable)}

            \State $startAddr \gets 0$
            \Comment{Start address of pool (inclusive)}

            \State $endAddr \gets 2^{16}$
            \Comment{End address of pool (exclusive)}

            \State $nextAddr \gets startAddr$
            \Comment{Next available address in pool}

            \State $freeList \gets \{\}$
            \Comment{List of freed blocks}\\

            \Function{alloc\_block}{$ $}
                \If {$|freeList| > 0$} \Comment{Check free-list}
                    \State $blk \gets freeList[0]$
                    \State $freeList = freeList - \{blk\}$
                    \State \Call{zero}{$blk$}
                    \State \Return $blk$
                \EndIf\\

                \If {$nextAddr + blockSize >= endAddr$}
                    \Comment{Out-of-memory}
                    \State \Return $-1$
                \EndIf\\

                \State $blk \gets nextAddr$
                \State $nextAddr \gets nextAddr + blockSize$
                \State \Call{zero}{$blk$}
                \State \Return $blk$
            \EndFunction\\
            \Function{free\_block}{$blk$}
                \If {$blk < startAddr \vee nextAddr <= blk \vee endAddr <= blk$}
                    \State \Return \Comment{Outside valid range}
                \EndIf\\

                \If {$blk - startAddr \not\equiv 0 \bmod{blockSize}$}
                    \State \Return \Comment{Unaligned}
                \EndIf\\

                \State $freeList = freeList \cup \{blk\}$
            \EndFunction
        \end{algorithmic}
    \end{algorithm}


\subsection{Metadata Layer}
    The metadata layer builds atop the block layer, and adds the ability for the
    allocator to store metadata about blocks. Since it is built upon the block
    layer, it must fit its metadata storage in blocks. To avoid a costly setup
    phase, the metadata layer uses a lazy, arena-based storage scheme. The
    general version of the metadata layer supports an arbitrary amount of
    metadata per block ranging from some non-zero amount of metadata to half the
    block size worth of metadata.

    For the sake of description, let us call the number of metadata fields that
    fit inside a block $k$. That is to say, one block can hold the metadata for
    $k$ blocks. The metadata layer discriminates between two types of blocks,
    data blocks and arena header blocks. The metadata layer implements a
    function that takes a block and returns its associated arena header block.
    For our purposes, this function acts as the identity function when passed
    an arena header block. These definitions lead to the notion that an arena
    header block is responsible for storing the metadata of itself, as well as
    the following $k-1$ blocks. The metadata layer is responsible for serving
    the user-facing API.

    See Algorithm \ref{code:mem_meta} for a pseudocode implementation of this
    layer. Note that this layer can also access the variables defined by the
    block layer (they can be found in Algorithm \ref{code:mem_block}). Also note that we have elided the code of several trivial helper functions. For
    example, we did not specify the body of the `get\_header' function. Since
    the implementation of this function was some simple modular arithmetic, we
    did not feel it was worth wasting the reader's time with such minutiae.

    While the metadata layer is parameterized on $k$, for our actual
    implementation, we chose $k$ to be equal to our block size; this implies
    the metadata for each process fits inside 1 byte. Indeed, we stored the
    owner pid of each block as the only metadata, and the bitwidth of the pid
    type in our system was 8.

    \begin{algorithm}
        \caption{Metadata layer pseudocode}
        \label{code:mem_meta}
        \begin{algorithmic}[1]

            \State $k \gets 2^7$
            \Comment{Blocks per arena (configurable)}

            \State $arenaSize \gets k * blockSize$
            \Comment{Arena size (in bytes)}

            \Function{request\_memory\_block}{$pid$}
                \State $header \gets -1$
                \State $blk \gets -1$ \\

                \State $blk \gets \Call{alloc\_block}{ }$
                \If {$blk = -1$}
                    \State \Return $-1$
                \EndIf\\

                \State $header \gets \Call{get\_header}{blk}$
                \If {$blk = header$}
                    \State $blk \gets \Call{alloc\_block}{ }$
                \EndIf\\

                \If {$blk = -1$}
                    \State \Return $-1$
                \EndIf\\

                \State \Call{set\_owner}{$header, blk, pid$}
                \State \Return $blk$
            \EndFunction\\
            \Function{free\_memory\_block}{$blk, pid$}
                \State $header \gets \Call{get\_header}{blk}$
                \If {$header = -1$}
                    \State \Return $-1$
                \EndIf\\

                \If {$ \neg \Call{is\_owner}{header, blk, pid}$}
                    \State \Return $-1$
                \EndIf\\

                \State \Call{set\_owner}{$header, blk, 0$}
                \State \Call{free\_block}{$blk$}
            \EndFunction
        \end{algorithmic}
    \end{algorithm}


\section{Theoretical Analysis}
    Both layers were carefully designed to be $O(1)$ for all operations. This
    should be trivial by inspection, as all the functions do a tiny amount of
    arithmetic, and considering we used a linked-list as the implementation of
    the free list.

    A slightly more interesting analysis is the space overhead of our metadata
    scheme. The metadata layer uses $\frac{k-1}{k}$ blocks for storing user
    data; this yields a storage overhead of $\frac{1}{k}$. For our
    implementation, we picked $k=2^7$, yielding an overhead of $0.78\%$, or a
    utilization rate of $99.22\%$.

\section{Measurements}
    % TODO(sanjay): do some measurements

\chapter{Message Passing}
% Make sure to include pseudocode and testing, if appropriate.

\section{Description}

\section{Running Time Analysis}

\section{Measurements}

\chapter{I/O}
% Make sure to include pseudocode and testing, if appropriate.

\section{UART output}

\section{UART input}

\chapter{Misc}
% Make sure to include pseudocode and testing, if appropriate.

\section{Bridge Layer}

\part{User-level Processes}

\chapter{Set Priority Command Process}

\section{Description}
    This process is responsible for allowing the user to change process
    priorities through terminal commands.  It is registered to the \%C command,
    and will attempt to set a new priority level to the given process ID.
    Validation is done on the input parameters to ensure that they are actually
    valid inputs before calling set\_process\_priority(pid, priority).  We check
    to ensure that we have a space between \%C, the pid, and the priority.  We
    also ensure that the pid is valid (within our allowed range of integers) and
    that the priority is valid (between 0 and 255 inclusive).  The
    set\_process\_priority process itself satisfies the requirements that the
    change be immediate and that the target process could be located in the
    ready or blocked resource queue.

    See Algorithm \ref{code:user_set_priority} for a pseudocode implementation
    of this user process.  Note that this process, among others, makes use of
    a custom implementation of a read\_uint32 helper function that we created.
    The pseudocode for that function is included in Algorithm
    \ref{code:read_uint32}.

    As a user process, we require memory in order to send a message to it (as
    the user), so we will be unable to send commands to it (as well as other
    user processes) in a situation where we are out of memory.  Therefore, we
    are unable to use this process to stop a misbehaving process that is holding
    and not releasing memory if we are already out of memory.

    \begin{algorithm}
        \caption{Set priority command process pseudocode}
        \label{code:user_set_priority}
        \begin{algorithmic}[1]
            \Function {setPriorityProcess}{}
                \State $envelope \gets \Call {request\_memory\_block}{}$
                \State \Call {init\_registration\_envelope}{$envelope, c$}
                \State \Call {send\_message}{$KEYBOARD\_PID, envelope$}\\

                \Loop
                    \State $envelope \gets \Call {receive\_message}{NULL}$\\

                    \If {$envelope \rightarrow srcPid \ne KEYBOARD\_PID$}
                        \State \Call {release\_memory\_block}{$envelope$}
                        \State $continue$
                    \EndIf\\

                    \If {$envelope\ message\ isn't\ prefixed\ with\ \%C$}
                        \State \Call {release\_memory\_block}{$envelope$}
                        \State $continue$
                    \EndIf\\

                    \State $status \gets \Call {processSetMessage}{envelope
                        \rightarrow message}$
                    \Comment {This will also call set\_process\_priority if the
                        contents pass validation}

                    \If {$status = EINVAL$}
                        \Comment {Print error message upon failure to validate}
                        \State \Call {printSetErrorMessage}{$envelope$}
                    \Else
                        \State \Call {release\_memory\_block}{$envelope$}
                    \EndIf
                \EndLoop
            \EndFunction
        \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}
        \caption{Read uint32 from char array pseudocode}
        \label{code:read_uint32}
        \begin{algorithmic}[1]
            \Function {read\_uint32}{$buf, out$}
                \Comment {buf is a char pointer}
                \State $number \gets 0$
                \Comment {The integer result}
                \State $read \gets 0$
                \Comment {Number of characters read}\\

                \If {$buf = NULL$}
                    \State \Return $0$
                    \Comment {Return if there's nothing to read}
                \EndIf\\

                \While {$read < \Call{len}{buf}$}
                    \If {\Call {$\neg$is\_numeric}{$buf \lbrack 0 \rbrack$}}
                        \State \textbf{break}
                    \EndIf\\

                    \State $number \gets number \times 10$
                    \State $number \gets number + \Call {to\_int}{buf \lbrack 0 \rbrack}$
                    \State $read \gets read + 1$
                    \State $buf \gets buf + 1$
                \EndWhile\\

                \If {$out \ne NULL$}
                    \State $out \lbrack 0 \rbrack \gets number$
                \EndIf\\

                \State \Return $read$
            \EndFunction
        \end{algorithmic}
    \end{algorithm}

\chapter{24-Hour Wall Clock Display Process}

\section{Description}
    This process is responsible for acting as a digital clock, printing the time
    at one second intervals.  The user can start the clock at 00:00:00 with the
    command \%WR, can stop output with \%WT, and can set an arbitrary time using
    \%WS HH:MM:SS.  The process will reject any messages passed to it that
    either don't begin with the registered \%W command, or are malformed.

    For the \%WS HH:MM:SS command, we check that there is a space in between
    \%WS and HH:MM:SS.  As well, we make sure that there are colons in between
    HH, MM, and SS.  We also ensure that HH is between 00 and 23 inclusive, and
    MM and SS are both between 00 and 59 inclusive.

    See Algorithm \ref{code:user_clock} for a pseudocode implementation
    of this user process.  Note that this process, among others, makes use of
    a few helper functions.  It uses read\_uint32, write\_uint32, as well as
    write\_string.  See Algorithm \ref{code:write_uint32} for the pseudocode of
    write\_uint32, and Algorithm \ref{code:write_string} for the pseudocode of
    write\_string.  In addition, a user API call get\_time is also used.  This
    simply obtains the current system counter, which is incremented every
    millisecond by the timer ISR.

    \begin{algorithm}
        \caption{Wall clock process pseudocode}
        \label{code:user_clock}
        \begin{algorithmic}[1]
            \State $receivedEnvelope \gets NULL$
            \Comment {Envelope for message passing}
            \State $selfEnvelope \gets \Call {request\_memory\_block}{}$
            \Comment {Cached envelope for self delayed messages}
            \State $cmdType \gets TERMINATE$
            \Comment {Action to take}
            \State $currentTime \gets 0$
            \Comment {Cached current time}
            \State $offset \gets 0$
            \Comment {Offset for calculating time}
            \State $isRunning \gets 0$
            \Comment {Boolean value for running state}\\

            \Function {parseClockMessage}{}
                \State $status \gets 0$
                \State $envelope \gets receivedEnvelope$\\

                \If {$envelope \rightarrow srcPid = CLOCK\_PID$}
                    \Comment {Received wake up, don't release memory}
                    \If {$isRunning$}
                        \Comment {If not terminated, print time}
                        \State $cmdType \gets PRINT\_TIME$
                    \EndIf
                    \State \Return
                \ElsIf {$envelope \rightarrow srcPid \ne KEYBOARD\_PID}$
                    \Comment {Ignore unwanted message}
                    \State \Call {release\_memory\_block}{$envelope$}
                    \State \Return
                \EndIf\\

                \If {$envelope \rightarrow message \lbrack 2 \rbrack = $'R'}
                    \State $cmdType \gets RESET\_TIME$
                \ElsIf {$envelope \rightarrow message \lbrack 2 \rbrack = $'T'}
                    \State $cmdType \gets TERMINATE$
                \ElsIf {$envelope \rightarrow message \lbrack 2 \rbrack = $'S'}
                    \State $cmdType \gets SET\_TIME$
                \Else
                    \State \Return
                \EndIf\\

                \If {$cmdType = RESET\_TIME$}
                    \State $offset \gets -1 \times currentTime$
        \algstore{wallClockProcess}
        \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}
        \begin{algorithmic}[1]
        \algrestore{wallClockProcess}
                    \If {$isRunning = 0$}
                        \Comment {Start clock if necessary}
                        \State $cmdType \gets PRINT\_TIME$
                    \EndIf
                \ElsIf {$cmdType = SET\_TIME$}
                    \State $status, offset \gets \Call {parseTime}{envelope}$
                        \Comment {Sets offset if validation is passed}
                    \If {$status = SUCCESS \&\& isRunning = 0$}
                        \Comment {Start clock if necessary}
                        \State $cmdType \gets PRINT\_TIME$
                    \EndIf
                \ElsIf {$cmdType = TERMINATE$}
                    \State $isRunning \gets 0$
                \EndIf\\

                \State \Call {release\_memory\_block}{$envelope$}
            \EndFunction\\

            \Function {clockProcess}{}
                \State $envelope \gets \Call {request\_memory\_block}{}$
                \State \Call {init\_registration\_envelope}{$envelope, w$}
                \State \Call {send\_message}{$KEYBOARD\_PID, envelope$}\\

                \Loop
                    \State $receivedEnvelope \gets \Call {receive\_message}{}$
                    \State $currentTime \gets \Call {get\_time}{}$\\

                    \State \Call {parseClockMessage}{}\\

                    \If {$cmdType = PRINT\_TIME$}
                        \Comment {Print the time in HH:MM:SS using the
                            calculated offset, and wake self in 1 second}
                        \State \Call {printTime}{$currentTime, offset$}
                        \State $isRunning \gets 1$
                        \State \Call {delayed\_send}{$CLOCK\_PID, selfEnvelope,
                            1000$}
                    \EndIf
                \EndLoop
            \EndFunction
        \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}
        \caption{Write uint32 to char array pseudocode}
        \label{code:write_uint32}
        \begin{algorithmic}[1]

            \Function{write\_uint32}{$buf, number, minDigits$}
                \Comment {buf is a char pointer}
                \State $tempNumber \gets number$
                \State $numDigits \gets 0$
                \Comment {Number of digits available}\\

                \While {$tempNumber > 0$}
                    \State $numDigits \gets numDigits + 1$
                    \State $tempNumber \gets tempNumber / 10$
                \EndWhile\\

                \If {$minDigits < 1$}
                    \State $minDigits \gets 1$
                \EndIf\\

                \If {$numDigits < minDigits$}
                    \State $numDigits \gets minDigits$
                \EndIf\\

                \If {$numDigits > \Call {len}{buf}$}
                    \State $numDigits \gets \Call {len}{buf}$
                \EndIf\\

                \State $tempNumber \gets numDigits$\\

                \While {$numDigits > 0$}
                    \If {$buf \ne NULL$}
                        \State $buf \lbrack numDigits - 1 \rbrack \gets \Call
                            {to\_char}{number \% 10}$
                    \EndIf\\

                    \State $number \gets number / 10$
                    \State $numDigits \gets numDigits - 1$
                \EndWhile\\

                \State \Return $tempNumber$
                \Comment {Returns number of digits read}
            \EndFunction
        \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}
        \caption{Write string to char array pseudocode}
        \label{code:write_string}
        \begin{algorithmic}[1]

            \Function{write\_string}{$buf, message$}
                \Comment {buf is a char pointer}
                \State $written \gets 0$
                \Comment {Number of characters written}
                \State $bufLen \gets \Call {len}{buf}$\\

                \If {$msg = NULL$}
                    \State \Return $0$
                    \Comment {Return if there's nothing to write}
                \EndIf\\

                \While {$msg \lbrack 0 \rbrack \ne NULL\_CHAR \&\&
                    bufLen > 0$}
                    \If {$buf \ne NULL$}
                        \State $buf \lbrack 0 \rbrack \gets msg \lbrack 0
                            \rbrack$
                        \State $buf \gets buf + 1$
                    \EndIf\\

                    \State $msg \gets msg + 1$
                    \State $bufLen \gets bufLen - 1$
                    \State $written \gets written + 1$
                \EndWhile\\

                \State \Return $written$
            \EndFunction
        \end{algorithmic}
    \end{algorithm}

\chapter{Stress Processes A, B, and C}

\chapter{User-Level Test Processes}

\part{Lessons Learned}
% They call this the lessons learned summary.
% 1-2 pages
% what you did do well, both technically and organizationally, and what you
% would do differently if you were to do it again

\end{document}
